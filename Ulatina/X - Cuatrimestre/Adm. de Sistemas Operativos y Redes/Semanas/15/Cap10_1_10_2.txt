Cap 10.1

Panorama general:

Sistemas multiprocesador: 
Estos sistemas tienen varias CPU, que pueden estar poco o muy acopladas. Son cada vez más comunes debido al auge de los procesadores multinúcleo.

Desafíos: 
La programación de trabajos en varias CPU presenta nuevos retos en comparación con los sistemas de una sola CPU, como la gestión de las cachés de hardware y la compartición de datos entre procesadores.

Conceptos clave:

Arquitectura multiprocesador:

Diferencias entre el hardware de una CPU y el de varias CPU.
Importancia de las cachés de hardware y de la compartición de datos.

Técnicas de programación:

Asignación estática vs. dinámica:
    Los procesos pueden asignarse a los procesadores de forma estática (asignación fija) o dinámica (bajo demanda).
Arquitectura maestro/esclavo frente a arquitectura de pares: 
    En la arquitectura maestro/esclavo, las funciones clave se ejecutan en un procesador específico, 
    mientras que en la arquitectura par, cualquier procesador puede ejecutar funciones del núcleo.

Granularidad del paralelismo:

Granularidad fina: 
    Alta frecuencia de sincronización, compleja de gestionar.
Granularidad media:
    Sincronización moderada, adecuada para aplicaciones multihilo.
Granularidad gruesa:
    Baja sincronización, más fácil de gestionar.
Paralelismo independiente:
    No necesita sincronización, típico en sistemas de tiempo compartido.

Cuestiones de diseño:
   
Asignación de procesos:
    Decidir si utilizar una cola común o colas individuales para los procesadores.
Multiprogramación: 
    Determinar si los procesadores deben ser multiprogramados.
Distribución de procesos: 
    selección de los procesos que se ejecutarán en un procesador.

Aplicaciones:

Aplicaciones multihilo:    
    Pueden utilizar varias CPU para ejecutarse más rápidamente repartiendo el trabajo entre los procesadores.
Sistemas operativos:
    Deben adaptarse para programar eficazmente los procesos y gestionar los recursos en entornos multiprocesador.

cap 10.2

Introducción: 
    Este capítulo profundiza en las técnicas y los retos de la programación de tareas en sistemas de tiempo real, donde cumplir los plazos es crucial. Abarca los siguientes puntos clave:

Pruebas de programabilidad:
    Introduce el concepto de pruebas de programabilidad para determinar si un conjunto de tareas puede cumplir sus plazos.
    Diferencia entre pruebas de programabilidad suficientes, exactas y necesarias.

Tiempo de ejecución en el peor de los casos (WCET):
    Discute métodos para estimar el WCET para tareas simples y complejas.
    Destaca las dificultades para determinar límites ajustados del WCET debido a las características de los procesadores modernos, como los pipelines y las cachés.

Algoritmos Anytime:
    Explica el uso de algoritmos en cualquier momento, que proporcionan un resultado básico rápidamente y lo mejoran con el tiempo si se dispone de más recursos informáticos.
    Estos algoritmos utilizan el intervalo entre el tiempo de ejecución real y la fecha límite para mejorar la calidad del resultado.

Programación estática:
    Introduce el concepto de programación estática y el periodo de programación.
    Proporciona un ejemplo de árbol de búsqueda utilizado para encontrar una programación factible.

Programación dinámica:
    Cubre el algoritmo rate-monotonic para programar tareas independientes.
    Discute el protocolo de techo de prioridad para programar tareas dependientes y proporciona una prueba de programabilidad para ello.
    Aborda la programación en sistemas distribuidos y estrategias alternativas como la programación por realimentación.

